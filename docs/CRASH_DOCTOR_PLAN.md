## Crash Doctor — MVP план и поэтапная реализация

Цель: автоматизировать диагностику и предложить правки сборки (board_state) по краш-логам. Премиум-фича.

### Почему делать сейчас
- Быстрый MVP возможен на базе существующих модулей (auth + rate limiter + build pipeline).
- Сильный пользовательский эффект: снятие боли «собрал — крашится — не знаю почему».
- Хорошо монитизируется (premium/pro), дорого по токенам — под лимитером.
- Риски контролируемы, если на первом этапе выдаём «предложения», а не авто-правки.

Рекомендация: стартовать с MVP сейчас, без авто-применения. Автофикс и автотест — последующие этапы.

### Скоп MVP (этап 1)
1) Ингест и санитизация логов
   - Вход: crash log (raw), optional game log; формат: текст или URL.
   - Санитизация: редактирование шумных/повторных строк, редактирование путей/PII, обрезка огромных блоков.
   - Классификация: загрузчик (fabric/forge/neoforge), версия ядра/игры, основные исключения.

2) Анализ и план фиксов (LLM + правила)
   - Контекст: sanitized logs + текущий `board_state` + известные зависимости (из нашей БД) + простые правила.
   - Выход: список операций с обоснованием и приоритетом:
     - удалить/отключить конфликтный мод;
     - добавить недостающую зависимость;
     - предложить альтернативную версию/мод;
     - включить `fabricCompatMode` и/или добавить совместимые «фикс»-моды.

3) Результат (без авто-применения)
   - JSON «план фиксов»: операции, обоснование, оценка уверенности, предполагаемый токен-кост.
   - Сгенерированный «patched_board_state» (черновик) — для предпросмотра/скачивания.

4) Ограничения и доступ
   - Эндпоинт за `@check_subscription_tier(required_tier='premium')` (или `pro`).
   - Проверка лимитов через существующий `rate_limiter` (счёт: 1 запрос + ai_tokens).

### Нефункциональные требования
- Безопасность: всегда редактируем PII в логах; лог храним только с явным согласием.
- Стоимость: лимиты на размер логов, усечение; токен-бюджет и ранний выход при низкой уверенности.
- Трассировка: записывать сессию в БД (inputs/вывод/решения, без сырых PII), для отладки качества.

### Архитектура (MVP)
- API (новое): `POST /api/ai/crash-doctor/analyze`
  - Body: `{ board_state, crash_logs, game_log?, mod_loader?, mc_version?, dry_run? }`
  - Ответ: `{ success, suggestions[], patched_board_state?, confidence, token_usage, warnings[] }`
- Компоненты:
  - Sanitizer: чистит/свёртывает лог, извлекает ключевые признаки (regex + эвристики).
  - Knowledge: минимальная база известных конфликтов/обязательных зависимостей (начать с нашего resolver + правил).
  - Planner (LLM): формирует операции; ограничиваем набор действий и размер контекста.
  - Patcher: строит черновик изменённого `board_state` (не применяет).
  - Recorder: сохраняет «сессию» (метаданные, план, токены) — для улучшений и поддержки.

### Модель данных (Supabase, эскиз)
- `crash_fix_sessions`
  - id (uuid), user_id, created_at
  - input_meta (json) — хэши/размеры, признаки (loader, mc_version)
  - sanitized_log (text) — опционально, если пользователь согласен
  - suggestions (json)
  - patched_board_state (json) — опционально
  - token_usage (json)
  - status (text: analyzed/applied/rejected)

### User Flow
1) Пользователь запускает игру → краш.
2) В лаунчере: «Вызвать Crash Doctor» → отправляем board_state + лог.
3) Получаем список предложений и черновик исправленного board_state.
4) Пользователь одобряет изменения → лаунчер локально применяет черновик и перезапускает.
   - (Этап 2+) API «apply» и автоперезапуск через раннер.

### Поэтапная дорожная карта
- Этап 1 (1–2 дня):
  - Эндпоинт analyze (premium), санитизация + LLM-план без авто-применения.
  - Интеграция с rate limiter, возврат token_usage.
  - Базовые правила (частые конфликты, отсутствие базовых зависимостей).

- Этап 2: Улучшение качества
  - Расширение базы известных конфликтов/зависимостей.
  - Более точная классификация загрузчика/версий и сигнатур исключений.
  - Сохранение сессий, аналитика, A/B промптов.

- Этап 3: Авто-применение (опционально)
  - Эндпоинт `apply` (подтверждение юзером), транзакционное применение патча board_state.
  - «Раннер» (локально в лаунчере): перезапуск игры, сбор нового лога, цикл до N попыток.

- Этап 4: Знаниевая база
  - Таблицы: `known_conflicts`, `required_dependencies`, «совместимость версий».
  - Полуавтоматическое пополнение из телеметрии и ручного куратора.

### Риски и гвардейлы
- Ложноположительные удаления: выдавать только предложения, с порогом confidence.
- Крупные логи: лимит размера, агрессивная свёртка.
- Конфиденциальность: строгая редакция PII, опция «не хранить лог».
- Стоимость: лимит токенов, ранняя остановка при низкой уверенности или «циклических» исключениях.

### Метрики успеха
- У доли сессий «analyzed» есть хотя бы 1 предложение с high confidence.
- Доля удачных фиксов после применения предложений (самоотчёт и, позже, автотелеметрия).
- Средний токен-кост/сессию в пределах бюджетов тарифа.


