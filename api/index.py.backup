"""
ASTRAL AI API Server
–õ–æ–∫–∞–ª—å–Ω—ã–π API –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è AI —Ñ—É–Ω–∫—Ü–∏–π
"""

from flask import Flask, request, jsonify
from flask_cors import CORS
from datetime import datetime, UTC
import os
import sys
import uuid
import time

# Load environment variables from .env
from dotenv import load_dotenv
load_dotenv()

# Dashboard WebSocket integration
try:
    from ws_emitter import (
        emit_pipeline_started, emit_stage_started, emit_stage_completed,
        emit_ai_call, emit_mod_selected, emit_log, emit_pipeline_completed
    )
    DASHBOARD_ENABLED = True
except ImportError:
    DASHBOARD_ENABLED = False
    print("‚ö†Ô∏è  Dashboard integration disabled (ws_emitter.py not found)")

sys.path.insert(0, os.path.dirname(__file__))
sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))

from ai_organize import organize_board
from ai_build import build_modpack as build_modpack_v1
from ai_build_v2 import build_modpack as build_modpack_v2
from ai_build_v3 import build_modpack as build_modpack_v3
from dependency_resolver import resolve_dependencies
from feedback_processor import process_feedback
from ai_auto_sort import auto_sort_mods
from smart_tagger import batch_get_mod_tags
from fabric_compat import get_fabric_compat_manager
from modpack_summary import generate_modpack_summary
from smart_categorizer import SmartCategorizer
from build_recorder import save_modpack_build, submit_feedback
from ai_sort_feedback import submit_sort_feedback
from config import DEEPSEEK_API_KEY, SUPABASE_URL, SUPABASE_KEY, CONNECTOR_MODS, BOARD_LAYOUT, CATEGORY_COLORS

app = Flask(__name__)
CORS(app)


@app.route('/health', methods=['GET'])
def health():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è —Å–µ—Ä–≤–µ—Ä–∞"""
    return jsonify({
        'status': 'ok',
        'service': 'ASTRAL AI API',
        'version': '1.0.0'
    })


@app.route('/api/ai/organize', methods=['POST'])
def api_organize_board():
    """
    AI –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è –¥–æ—Å–∫–∏
    
    –ü—Ä–∏–Ω–∏–º–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –º–æ–¥–æ–≤, –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∏—Ö –∏ —Å–æ–∑–¥–∞—ë—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    """
    try:
        data = request.json
        
        # –í–∞–ª–∏–¥–∞—Ü–∏—è
        if not data or 'mods' not in data:
            return jsonify({
                'error': 'Invalid request',
                'message': 'mods array is required'
            }), 400
        
        mods = data['mods']
        
        if len(mods) == 0:
            return jsonify({
                'error': 'No mods provided',
                'message': 'At least one mod is required'
            }), 400
        
        print(f"üì¶ Organizing {len(mods)} mods...")
        
        # –í—ã–∑—ã–≤–∞–µ–º AI –ª–æ–≥–∏–∫—É
        result = organize_board(
            mods=mods,
            deepseek_key=DEEPSEEK_API_KEY
        )
        
        print(f"‚úÖ Created {len(result['categories'])} categories")
        
        return jsonify({
            'success': True,
            'organization': result,
            'stats': {
                'total_mods': len(mods),
                'categories_created': len(result['categories'])
            }
        })
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'error': 'Internal server error',
            'message': str(e)
        }), 500


@app.route('/api/ai/build', methods=['POST'])
def api_build_modpack():
    """
    AI —Å–±–æ—Ä–∫–∞ –º–æ–¥–ø–∞–∫–∞
    
    –ü—Ä–∏–Ω–∏–º–∞–µ—Ç –ø—Ä–æ–º–ø—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —Ç–µ–∫—É—â–∏–µ –º–æ–¥—ã –Ω–∞ –¥–æ—Å–∫–µ,
    –ø–æ–¥–±–∏—Ä–∞–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –º–æ–¥—ã –∏–∑ –ë–î
    """
    try:
        data = request.json
        
        # –í–∞–ª–∏–¥–∞—Ü–∏—è
        if not data or 'prompt' not in data:
            return jsonify({
                'error': 'Invalid request',
                'message': 'prompt is required'
            }), 400
        
        prompt = data['prompt']
        mc_version = data.get('mc_version', '1.21.1')
        mod_loader = data.get('mod_loader', 'fabric')
        current_mods = data.get('current_mods', [])
        max_mods = data.get('max_mods', 30)
        
        print(f"ü§ñ Building modpack for: {prompt}")
        print(f"   Version: {mc_version}, Loader: {mod_loader}")
        print(f"   Current mods: {len(current_mods)}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–µ—Ä—Å–∏—é API (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é v3)
        use_v3 = data.get('use_v3_architecture', True)
        use_v2 = data.get('use_v2_architecture', False)
        
        if use_v3:
            build_func = build_modpack_v3
            print("   üèóÔ∏è  Using V3 (Architecture-First for themed modpacks)")
        elif use_v2:
            build_func = build_modpack_v2
            print("   üöÄ Using V2 (3-layer architecture)")
        else:
            build_func = build_modpack_v1
            print("   üì¶ Using LEGACY V1")
        
        # –í—ã–∑—ã–≤–∞–µ–º AI –ª–æ–≥–∏–∫—É
        result = build_func(
            prompt=prompt,
            mc_version=mc_version,
            mod_loader=mod_loader,
            current_mods=current_mods,
            max_mods=max_mods,
            deepseek_key=DEEPSEEK_API_KEY,
            supabase_url=SUPABASE_URL,
            supabase_key=SUPABASE_KEY
        )
        
        print(f"‚úÖ Selected {len(result['mods'])} mods")
        
        return jsonify({
            'success': True,
            'modpack': result,
            'stats': {
                'selected_mods': len(result['mods']),
                'new_mods': len([m for m in result['mods'] if m.get('is_new', True)])
            }
        })
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'error': 'Internal server error',
            'message': str(e)
        }), 500


@app.route('/api/ai/build-board', methods=['POST'])
def api_build_board_state():
    """
    AI —Å–±–æ—Ä–∫–∞ –º–æ–¥–ø–∞–∫–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ board_state.json
    
    –°–æ–∑–¥–∞—ë—Ç –≥–æ—Ç–æ–≤—ã–π —Ñ–∞–π–ª –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤ –ª–∞—É–Ω—á–µ—Ä
    """
    # üéØ DASHBOARD: Generate pipeline ID and track start time
    pipeline_id = str(uuid.uuid4())
    start_time = time.time()
    
    # ‚è±Ô∏è TIMING: Track stage durations
    stage_timings = {}
    
    try:
        data = request.json
        
        # –í–∞–ª–∏–¥–∞—Ü–∏—è
        if not data or 'prompt' not in data:
            return jsonify({
                'error': 'Invalid request',
                'message': 'prompt is required'
            }), 400
        
        prompt = data['prompt']
        mc_version = data.get('mc_version', '1.21.1')
        mod_loader = data.get('mod_loader', 'fabric')
        current_mods = data.get('current_mods', [])
        max_mods = data.get('max_mods', 30)
        project_id = data.get('project_id', 'ai-generated-modpack')
        fabric_compat_mode = data.get('fabric_compat_mode', False)
        
        print(f"ü§ñ Building board_state.json for: {prompt}")
        print(f"üîß Current mods ({len(current_mods)}): {current_mods}")
        print(f"üéÆ mc_version={mc_version}, mod_loader={mod_loader}, max_mods={max_mods}")
        print(f"üîß Fabric Compat Mode: {'ENABLED' if fabric_compat_mode else 'DISABLED'}")
        
        # üéØ DASHBOARD: Emit pipeline started event
        if DASHBOARD_ENABLED:
            emit_pipeline_started(pipeline_id, prompt, mc_version, mod_loader, max_mods)
            emit_log(pipeline_id, "info", f"üöÄ Starting modpack builder for: {prompt}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–µ—Ä—Å–∏—é API
        use_v3 = data.get('use_v3_architecture', True)
        use_v2 = data.get('use_v2_architecture', False)
        
        if use_v3:
            build_func = build_modpack_v3
            print("   üèóÔ∏è  Using V3 (Architecture-First)")
        elif use_v2:
            build_func = build_modpack_v2
            print("   üöÄ Using V2")
        
        # üéØ DASHBOARD: Emit Query Planner stage
        if DASHBOARD_ENABLED:
            emit_stage_started(pipeline_id, "Query Planner", "Analyzing user request")
        
        # –í—ã–∑—ã–≤–∞–µ–º AI –ª–æ–≥–∏–∫—É
        stage_start = time.time()
        result = build_func(
            prompt=prompt,
            mc_version=mc_version,
            mod_loader=mod_loader,
            current_mods=current_mods,
            max_mods=max_mods,  # –ü–µ—Ä–µ–¥–∞—ë–º –ø–æ–ª–Ω—ã–π –ª–∏–º–∏—Ç - dependency_resolver —Å–∞–º —É–ø—Ä–∞–≤–ª—è–µ—Ç –ª–∏–º–∏—Ç–æ–º
            fabric_compat_mode=fabric_compat_mode,
            deepseek_key=DEEPSEEK_API_KEY,
            supabase_url=SUPABASE_URL,
            supabase_key=SUPABASE_KEY,
            pipeline_id=pipeline_id  # üéØ DASHBOARD: Pass pipeline ID
        )
        stage_timings['Mod Selection'] = time.time() - stage_start
        
        # üéØ DASHBOARD: Emit stage completion and track mods selected
        if DASHBOARD_ENABLED:
            emit_stage_completed(pipeline_id, "Mod Selection", 0)
            for mod in result.get('mods', [])[:10]:  # First 10 mods for demo
                emit_mod_selected(pipeline_id, "Mod Selection", mod.get('slug', ''), mod.get('name', ''))
        
        # ========================================================================
        # DEPENDENCY RESOLUTION (AFTER AI SELECTION, BEFORE FABRIC FIX)
        # ========================================================================
        if DASHBOARD_ENABLED:
            emit_stage_started(pipeline_id, "Dependency Resolver", "Resolving mod dependencies")
        
        stage_start = time.time()
        deps_before = len(result['mods'])
        result['mods'] = resolve_dependencies(
            selected_mods=result['mods'],
            mc_version=mc_version,
            mod_loader=mod_loader,
            supabase_url=SUPABASE_URL,
            supabase_key=SUPABASE_KEY
            # max_total_mods —É–¥–∞–ª–µ–Ω - dependencies –±–æ–ª—å—à–µ –Ω–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω—ã
        )
        deps_added = len(result['mods']) - deps_before
        stage_timings['Dependency Resolution'] = time.time() - stage_start
        
        if DASHBOARD_ENABLED:
            emit_stage_completed(pipeline_id, "Dependency Resolver", 0)
            if deps_added > 0:
                emit_log(pipeline_id, "success", f"‚úÖ Added {deps_added} dependencies", "Dependency Resolver")
        
        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç board_state.json —Å –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏
        from collections import defaultdict
        
        # ========================================================================
        # ARCHITECTURE REFINER (V3 only - —É—Ç–æ—á–Ω—è–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ—Å–ª–µ dependencies)
        # ========================================================================
        planned_architecture = result.get('planned_architecture')
        
        if planned_architecture:
            from architecture_refiner import refine_architecture
            
            print()
            print("[ARCHITECTURE REFINER] Refining categories based on actual mods")
            print("-" * 80)
            
            if DASHBOARD_ENABLED:
                emit_stage_started(pipeline_id, "Architecture Refiner", "Refining categories based on selected mods")
            
            refiner_start = time.time()
            refined_architecture = refine_architecture(
                initial_architecture=planned_architecture,
                mods=result['mods'],
                user_prompt=prompt,
                deepseek_key=DEEPSEEK_API_KEY
            )
            
            if refined_architecture:
                # –ó–∞–º–µ–Ω—è–µ–º planned_architecture –Ω–∞ refined
                result['planned_architecture'] = refined_architecture
                planned_architecture = refined_architecture
                stage_timings['Architecture Refiner'] = time.time() - refiner_start
                
                if DASHBOARD_ENABLED:
                    # Track AI tokens
                    if '_tokens' in refined_architecture:
                        tokens = refined_architecture['_tokens']
                        emit_ai_call(
                            pipeline_id, "Architecture Refiner", "deepseek", "deepseek-chat",
                            tokens.get('prompt_tokens', 0),
                            tokens.get('completion_tokens', 0),
                            tokens.get('cost_usd', 0),
                            0
                        )
                    
                    emit_stage_completed(pipeline_id, "Architecture Refiner", (time.time() - refiner_start) * 1000)
                    emit_log(pipeline_id, "success", f"‚úÖ Refined to {len(refined_architecture.get('categories', []))} categories", "Architecture Refiner")
                
                print()
        
        # ========================================================================
        # FABRIC COMPATIBILITY AUTO-ADD (–∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–Ω—Ñ–∏–≥)
        # ========================================================================
        stage_start = time.time()
        fabric_compat_manager = get_fabric_compat_manager()
        FABRIC_FIX_IDS = fabric_compat_manager.config['auto_enable_triggers']['connector_mods']
        
        if fabric_compat_mode:
            print()
            print("üîß Fabric Compat Mode enabled...")
            print("-" * 80)
            
            # –§–µ—Ç—á–∏–º compatibility –º–æ–¥—ã —á–µ—Ä–µ–∑ –º–µ–Ω–µ–¥–∂–µ—Ä
            fabric_fix_mods = fabric_compat_manager.fetch_compatibility_mods(
                mod_loader=mod_loader,
                mc_version=mc_version,
                supabase_url=SUPABASE_URL,
                supabase_key=SUPABASE_KEY
            )
            
            # –î–æ–±–∞–≤–ª—è–µ–º –≤ –Ω–∞—á–∞–ª–æ result['mods']
            if fabric_fix_mods:
                result['mods'] = fabric_fix_mods + result['mods']
                print(f"   ‚úÖ Added {len(fabric_fix_mods)} compatibility mods to modpack")
            
            print()
        else:
            # –†–µ–∂–∏–º –≤—ã–∫–ª—é—á–µ–Ω - —É–¥–∞–ª—è–µ–º Fabric Fix –º–æ–¥—ã, –µ—Å–ª–∏ –æ–Ω–∏ –ø–æ–ø–∞–ª–∏ —á–µ—Ä–µ–∑ dependencies
            before_count = len(result['mods'])
            result['mods'] = [mod for mod in result['mods'] if mod.get('source_id', '') not in FABRIC_FIX_IDS]
            filtered_count = before_count - len(result['mods'])
            if filtered_count > 0:
                print(f"\n‚ö†Ô∏è  Fabric Compat Mode disabled: filtered out {filtered_count} Fabric Fix mods")
        
        stage_timings['Fabric Compatibility'] = time.time() - stage_start
        
        # ========================================================================
        # SMART CATEGORIZATION (conditional - skip for v3 themed_pack)
        # ========================================================================
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ (v3 themed_pack)
        planned_architecture = result.get('planned_architecture')
        
        # ========================================================================
        # SAVE BUILD TO DB (—Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–±–æ—Ä–∫—É –î–û board_state –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏)
        # ========================================================================
        pack_archetype = planned_architecture.get('meta', {}).get('pack_archetype') if planned_architecture else None
        modpack_title = f'AI Modpack ({prompt[:30]}...)'  # –í—Ä–µ–º–µ–Ω–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ, summary –µ—â—ë –Ω–µ—Ç
        
        build_id = save_modpack_build(
            title=modpack_title,
            prompt=prompt,
            mc_version=mc_version,
            mod_loader=mod_loader,
            pack_archetype=pack_archetype,
            mods=result['mods'],
            supabase_url=SUPABASE_URL,
            supabase_key=SUPABASE_KEY
        )
        print(f"üíæ [Build Saved] build_id={build_id}")
        
        if planned_architecture:
            # V3 THEMED PACK: –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—É—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É
            print("[ARCHITECTURE-BASED CATEGORIZATION] Using planned categories from V3")
            print("-" * 80)
            print(f"   ‚úÖ Using {len(planned_architecture.get('categories', []))} pre-planned categories")
            
            # AI-BASED DISTRIBUTION: –∏—Å–ø–æ–ª—å–∑—É–µ–º AI –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
            from architecture_refiner import distribute_mods_to_categories
            
            stage_start = time.time()
            # –û—Ç–¥–µ–ª—è–µ–º Fabric Compatibility –º–æ–¥—ã
            fabric_fix_mods = [mod for mod in result['mods'] if mod.get('source_id', '') in FABRIC_FIX_IDS]
            regular_mods = [mod for mod in result['mods'] if mod.get('source_id', '') not in FABRIC_FIX_IDS]
            
            # AI —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–æ–ª—å–∫–æ gameplay –º–æ–¥—ã
            ai_category_map = distribute_mods_to_categories(
                categories=planned_architecture['categories'],
                mods=regular_mods,
                user_prompt=prompt,
                deepseek_key=DEEPSEEK_API_KEY
            )
            stage_timings['Mod Distribution'] = time.time() - stage_start
            
            # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –í–°–ï –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏–∑ planned_architecture
            category_map = {}
            for category in planned_architecture.get('categories', []):
                cat_name = category['name']
                category_map[cat_name] = ai_category_map.get(cat_name, [])
            
            # –í–ê–ñ–ù–û: –î–æ–±–∞–≤–ª—è–µ–º fallback –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏–∑ ai_category_map (Performance, Libraries, Graphics)
            for cat_name, mods_list in ai_category_map.items():
                if cat_name not in category_map:
                    category_map[cat_name] = mods_list
                    print(f"   ‚ûï Added fallback category from AI: '{cat_name}' with {len(mods_list)} mods")
            
            # –î–æ–±–∞–≤–ª—è–µ–º fallback –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
            category_map['General'] = []
            
            # Fabric Compatibility —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ fabric_compat_mode=True
            if fabric_compat_mode and fabric_fix_mods:
                category_map['Fabric Compatibility'] = fabric_fix_mods
            else:
                # –ï—Å–ª–∏ —Ä–µ–∂–∏–º –≤—ã–∫–ª—é—á–µ–Ω, –Ω–æ –º–æ–¥—ã –ø–æ–ø–∞–ª–∏ - –∫–∏–¥–∞–µ–º –≤ General
                if fabric_fix_mods:
                    category_map['General'].extend(fabric_fix_mods)
            
            # –ù–µ—Ä–∞—Å–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–µ –º–æ–¥—ã –∏–¥—É—Ç –≤ General
            assigned_mods = set()
            for mods_list in ai_category_map.values():
                for mod in mods_list:
                    assigned_mods.add(mod.get('slug'))
            
            unassigned_mods = [mod for mod in regular_mods if mod.get('slug') not in assigned_mods]
            if unassigned_mods:
                category_map['General'].extend(unassigned_mods)
            
            # –í—ã–≤–æ–¥–∏–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
            print(f"\nüìä [Distribution Results]")
            # Refiner –∏—Å–ø–æ–ª—å–∑—É–µ—Ç estimated_mods, Planner –∏—Å–ø–æ–ª—å–∑—É–µ—Ç target_mods
            planned_cats = {cat['name']: cat.get('estimated_mods', cat.get('target_mods', 0)) 
                          for cat in planned_architecture.get('categories', [])}
            
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º: —Å–Ω–∞—á–∞–ª–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —Å –º–æ–¥–∞–º–∏, –ø–æ—Ç–æ–º –ø—É—Å—Ç—ã–µ
            non_empty_cats = [(name, mods) for name, mods in category_map.items() if len(mods) > 0 and name not in ['General', 'Fabric Compatibility']]
            empty_cats = [(name, mods) for name, mods in category_map.items() if len(mods) == 0]
            fallback_cats = [(name, mods) for name, mods in category_map.items() if name in ['General', 'Fabric Compatibility']]
            
            # –ö–∞—Ç–µ–≥–æ—Ä–∏–∏ —Å –º–æ–¥–∞–º–∏ (—Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É)
            for cat_name, mods_list in sorted(non_empty_cats, key=lambda x: -len(x[1])):
                target = planned_cats.get(cat_name, 0)
                actual = len(mods_list)
                percentage = (actual / target * 100) if target > 0 else 0
                status = "‚úÖ" if percentage >= 70 else "‚ö†Ô∏è"
                print(f"   {status} {cat_name}: {actual}/{target} mods ({percentage:.0f}%)")
            
            # –ü—É—Å—Ç—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
            for cat_name, mods_list in empty_cats:
                target = planned_cats.get(cat_name, 0)
                print(f"   ‚ùå {cat_name}: 0/{target} mods (empty)")
            
            # Fallback –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
            for cat_name, mods_list in fallback_cats:
                if len(mods_list) > 0:
                    print(f"   üì¶ {cat_name}: {len(mods_list)} mods (fallback)")
            print()
            
        else:
            # V2 FLOW: Smart Categorizer
            print("[SMART CATEGORIZER] AI-based mod categorization")
            print("-" * 80)
            
            stage_start = time.time()
            # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏–∏
            mods_for_categorization = []
            fabric_fix_mods = []
            
            for mod in result['mods']:
                if mod.get('source_id', '') in FABRIC_FIX_IDS:
                    fabric_fix_mods.append(mod)
                else:
                    mods_for_categorization.append({
                        'name': mod['name'],
                        'summary': mod.get('summary', mod.get('description', '')[:200]),
                        'tags': mod.get('tags', [])
                    })
            
            # –í—ã–∑—ã–≤–∞–µ–º smart categorizer
            categorized_mods = []
            if mods_for_categorization:
                try:
                    categorizer = SmartCategorizer(api_key=DEEPSEEK_API_KEY)
                    categorized_mods = categorizer.categorize_mods(mods_for_categorization)
                    print(f"‚úÖ AI categorized {len(categorized_mods)} mods")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Smart categorizer failed: {e}")
                    print("   Falling back to tag-based categorization...")
                    categorized_mods = []
                    for mod_data in mods_for_categorization:
                        mod_data['category'] = 'Other'
                        categorized_mods.append(mod_data)
            
            # –°–æ–∑–¥–∞—ë–º mapping: –∏–º—è –º–æ–¥–∞ -> –∫–∞—Ç–µ–≥–æ—Ä–∏—è
            mod_category_map = {mod['name']: mod['category'] for mod in categorized_mods}
            
            # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –º–æ–¥—ã –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
            category_map = defaultdict(list)
            
            # Fabric Fix –º–æ–¥—ã —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω fabric_compat_mode
            if fabric_compat_mode and fabric_fix_mods:
                category_map['Fabric Compatibility'] = fabric_fix_mods
                print(f"   üìÅ Fabric Compatibility: {len(fabric_fix_mods)} mods")
            elif fabric_fix_mods:
                # –∏–Ω–∞—á–µ –Ω–µ —Å–æ–∑–¥–∞—ë–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏ –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –µ—ë –æ—Ç–¥–µ–ª—å–Ω–æ; –º–æ–¥—ã —É–π–¥—É—Ç –≤ –æ–±—â–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏/General
                pass
            
            # AI-–∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–æ–¥—ã
            for mod in result['mods']:
                if mod.get('source_id', '') not in FABRIC_FIX_IDS:
                    category_name = mod_category_map.get(mod['name'], 'Other')
                    category_map[category_name].append(mod)
            
            # –í—ã–≤–æ–¥–∏–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            for cat_name, mods_list in category_map.items():
                if cat_name != 'Fabric Compatibility':
                    print(f"   üìÅ {cat_name}: {len(mods_list)} mods")
            print()
            
            stage_timings['Smart Categorizer'] = time.time() - stage_start
        
        # ========================================================================
        # BOARD STATE GENERATION
        # ========================================================================
        stage_start = time.time()
        
        # –¶–≤–µ—Ç–∞ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π (—Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –ø–∞–ª–∏—Ç—Ä–∞ —Å —Å–∏–Ω–æ–Ω–∏–º–∞–º–∏)
        category_colors = {
            # Fabric Fix
            'fabric': ('#ff9500', '#000000'),
            'compatibility': ('#ff9500', '#000000'),
            
            # Performance
            'performance': ('#22c55e', '#16a34a'),
            'optimization': ('#22c55e', '#16a34a'),
            
            # Libraries/Core
            'library': ('#3b82f6', '#2563eb'),
            'api': ('#3b82f6', '#2563eb'),
            'core': ('#3b82f6', '#2563eb'),
            'foundation': ('#3b82f6', '#2563eb'),
            'system': ('#3b82f6', '#2563eb'),
            
            # Utility
            'utility': ('#f59e0b', '#d97706'),
            'tool': ('#f59e0b', '#d97706'),
            'quality': ('#f59e0b', '#d97706'),
            
            # Graphics/Visual
            'graphics': ('#ec4899', '#db2777'),
            'visual': ('#ec4899', '#db2777'),
            'shader': ('#ec4899', '#db2777'),
            'lighting': ('#ec4899', '#db2777'),
            'enhancement': ('#ec4899', '#db2777'),
            
            # World/Terrain
            'world': ('#10b981', '#059669'),
            'terrain': ('#10b981', '#059669'),
            'biome': ('#10b981', '#059669'),
            'realm': ('#10b981', '#059669'),
            'generation': ('#10b981', '#059669'),
            
            # Combat/Weapons
            'combat': ('#ef4444', '#dc2626'),
            'weapon': ('#ef4444', '#dc2626'),
            'armor': ('#ef4444', '#dc2626'),
            'knight': ('#ef4444', '#dc2626'),
            'armory': ('#ef4444', '#dc2626'),
            'fight': ('#ef4444', '#dc2626'),
            
            # Building/Architecture
            'building': ('#f97316', '#ea580c'),
            'architecture': ('#f97316', '#ea580c'),
            'construction': ('#f97316', '#ea580c'),
            'castle': ('#f97316', '#ea580c'),
            
            # Decoration
            'decoration': ('#ec4899', '#db2777'),
            'furniture': ('#ec4899', '#db2777'),
            'aesthetic': ('#ec4899', '#db2777'),
            
            # Technology
            'technology': ('#06b6d4', '#0891b2'),
            'machine': ('#06b6d4', '#0891b2'),
            'automation': ('#06b6d4', '#0891b2'),
            
            # Magic/Fantasy
            'magic': ('#a855f7', '#9333ea'),
            'spell': ('#a855f7', '#9333ea'),
            'arcane': ('#a855f7', '#9333ea'),
            'fantasy': ('#a855f7', '#9333ea'),
            'mystical': ('#a855f7', '#9333ea'),
            
            # Creatures/Mobs
            'creature': ('#8b5cf6', '#7c3aed'),
            'mob': ('#8b5cf6', '#7c3aed'),
            'beast': ('#8b5cf6', '#7c3aed'),
            'bestiary': ('#8b5cf6', '#7c3aed'),
            
            # Village/NPCs
            'village': ('#eab308', '#ca8a04'),
            'npc': ('#eab308', '#ca8a04'),
            'villager': ('#eab308', '#ca8a04'),
            'life': ('#eab308', '#ca8a04'),
            
            # Food/Farming
            'food': ('#84cc16', '#65a30d'),
            'farm': ('#84cc16', '#65a30d'),
            'cooking': ('#84cc16', '#65a30d'),
            
            # Adventure/Exploration
            'adventure': ('#eab308', '#ca8a04'),
            'exploration': ('#eab308', '#ca8a04'),
            'dungeon': ('#eab308', '#ca8a04'),
            
            # Transportation
            'transportation': ('#14b8a6', '#0d9488'),
            'vehicle': ('#14b8a6', '#0d9488'),
            
            # Crafting
            'craft': ('#f59e0b', '#d97706'),
            'craftsmanship': ('#f59e0b', '#d97706'),
            
            # Multiplayer
            'multiplayer': ('#8b5cf6', '#7c3aed'),
            
            # Fallback
            'other': ('#6b7280', '#4b5563'),
            'general': ('#6b7280', '#4b5563')
        }
        
        # 2. –°–æ–∑–¥–∞—ë–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º
        board_state = {
            "project_id": project_id,
            "camera": {
                "scale": 1.0,
                "tx": 0.0,
                "ty": 0.0
            },
            "mods": [],
            "categories": [],
            "updated_at": datetime.now(UTC).isoformat(),
            "_ai_generated": True,  # –§–ª–∞–≥ —á—Ç–æ —ç—Ç–æ –º–æ–¥–ø–∞–∫ –æ—Ç AI
            "_batch_download": True,  # –õ–∞—É–Ω—á–µ—Ä –¥–æ–ª–∂–µ–Ω —Å–∫–∞—á–∞—Ç—å –≤—Å–µ –º–æ–¥—ã —Å—Ä–∞–∑—É (–ø–∞—á–∫–æ–π)
            "_ai_build_id": str(build_id) if build_id else None  # ID —Å–±–æ—Ä–∫–∏ –¥–ª—è —Ñ–∏–¥–±–µ–∫–∞ (—Å—Ç—Ä–æ–∫–∞)
        }
        
        # –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è (–°–ò–ù–•–†–û–ù–ò–ó–ò–†–û–í–ê–ù–û –° boardConstants.ts)
        MOD_WIDTH = 240
        MOD_HEIGHT = 80
        MOD_GAP = 10
        CATEGORY_HEADER = 40
        CATEGORY_PADDING_TOP = 8
        CATEGORY_PADDING_BOTTOM = 8
        CATEGORY_WIDTH = 255  # Fixed width: mod width (240) + 15px
        
        CATEGORY_SPACING_X = 350  # –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏ –ø–æ X
        CATEGORY_SPACING_Y = 100  # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –æ—Ç—Å—Ç—É–ø –ø–æ Y
        START_X = 100
        START_Y = 100
        
        current_x = START_X
        current_y = START_Y
        max_height_in_row = 0
        categories_per_row = 4  # –ú–∞–∫—Å–∏–º—É–º 4 –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤ —Ä—è–¥
        category_index = 0
        
        for category_name, mods_in_category in category_map.items():
            if not mods_in_category:
                continue
            
            # –í—ã—á–∏—Å–ª—è–µ–º –≤—ã—Å–æ—Ç—É –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
            mod_count = len(mods_in_category)
            category_height = CATEGORY_HEADER + CATEGORY_PADDING_TOP + \
                            (mod_count * MOD_HEIGHT) + \
                            ((mod_count - 1) * MOD_GAP) + \
                            CATEGORY_PADDING_BOTTOM
            
            # –ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É
            if category_index > 0 and category_index % categories_per_row == 0:
                current_x = START_X
                current_y += max_height_in_row + CATEGORY_SPACING_Y
                max_height_in_row = 0
            
            # –¶–≤–µ—Ç–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ (—É–º–Ω—ã–π matching)
            category_lower = category_name.lower()
            colors = category_colors['other']  # Default
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
            for key, color_pair in category_colors.items():
                if key in category_lower:
                    colors = color_pair
                    break
            
            # –£–Ω–∏–∫–∞–ª—å–Ω—ã–π ID —Å timestamp
            category_id = f"ai-category-{category_name.lower().replace(' ', '-')}-{int(datetime.now(UTC).timestamp() * 1000)}"
            
            # –°–æ–∑–¥–∞—ë–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é
            board_state['categories'].append({
                "id": category_id,
                "title": category_name,
                "position": {"x": current_x, "y": current_y},
                "size": {"width": CATEGORY_WIDTH, "height": category_height},
                "color1": colors[0],
                "color2": colors[1]
            })
            
            # –î–æ–±–∞–≤–ª—è–µ–º –º–æ–¥—ã –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏—é
            for mod_index, mod in enumerate(mods_in_category):
                # –ü–æ–∑–∏—Ü–∏—è –º–æ–¥–∞ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ (—Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–æ)
                mod_x = current_x + (CATEGORY_WIDTH - MOD_WIDTH) / 2
                mod_y = current_y + CATEGORY_HEADER + CATEGORY_PADDING_TOP + \
                        mod_index * (MOD_HEIGHT + MOD_GAP)
                
                mod_node = {
                    "project_id": mod.get('source_id', mod['slug']),
                    "slug": mod['slug'],  # Add slug for Modrinth links
                    "position": {"x": mod_x, "y": mod_y},
                    "title": mod['name'],
                    "icon_url": mod.get('icon_url'),
                    "description": mod.get('summary', mod.get('description', '')[:200]),  # Use summary or first 200 chars
                    "file_name": None,
                    "unique_id": f"{mod['slug']}_{int(datetime.now(UTC).timestamp())}_{mod_index}",
                    "is_disabled": False,
                    "cached_dependencies": [],
                    "dependencies_fetched": False,
                    "category_id": category_id,
                    "category_index": mod_index
                }
                
                board_state['mods'].append(mod_node)
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
            current_x += CATEGORY_SPACING_X
            max_height_in_row = max(max_height_in_row, category_height)
            category_index += 1
        
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤–∫–ª—é—á–∞–µ–º fabricCompatMode –µ—Å–ª–∏ –µ—Å—Ç—å Fabric Compatibility –∫–∞—Ç–µ–≥–æ—Ä–∏—è
        has_fabric_category = any(
            cat['title'] == 'Fabric Compatibility' 
            for cat in board_state['categories']
        )
        
        if has_fabric_category:
            board_state['fabricCompatMode'] = True
            print("üîß Auto-enabled fabricCompatMode (Fabric Compatibility category detected)")
        
        stage_timings['Board State Generation'] = time.time() - stage_start
        
        print(f"‚úÖ Generated board_state.json with {len(board_state['mods'])} mods and {len(board_state['categories'])} categories")
        for cat in board_state['categories']:
            category_mods = [m for m in board_state['mods'] if m.get('category_id') == cat['id']]
            mods_count = len(category_mods)
            print(f"   üìÅ {cat['title']}: {mods_count} mods")
            
            # –í—ã–≤–æ–¥–∏–º slug'–∏ –º–æ–¥–æ–≤ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ (–ø–µ—Ä–≤—ã–µ 10 –¥–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏)
            if category_mods:
                mod_slugs = [m.get('slug', 'unknown') for m in category_mods]
                if len(mod_slugs) <= 10:
                    for slug in mod_slugs:
                        print(f"      ‚Ä¢ {slug}")
                else:
                    for slug in mod_slugs[:10]:
                        print(f"      ‚Ä¢ {slug}")
                    print(f"      ... and {len(mod_slugs) - 10} more")
        
        # ========================================================================
        # GENERATE MODPACK SUMMARY (AI-powered description)
        # ========================================================================
        print()
        stage_start = time.time()
        modpack_summary = generate_modpack_summary(
            prompt=prompt,
            categories=board_state['categories'],
            mods=result['mods'],  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –º–æ–¥—ã —Å —Ñ–ª–∞–≥–∞–º–∏ _added_as_dependency
            mc_version=mc_version,
            mod_loader=mod_loader,
            deepseek_key=DEEPSEEK_API_KEY
        )
        stage_timings['Modpack Summary'] = time.time() - stage_start
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ —Å–±–æ—Ä–∫–∏ –≤ –ë–î (–µ—Å–ª–∏ –µ—Å—Ç—å summary)
        if build_id and modpack_summary.get('title'):
            # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∏—Ç—É–ª –≤ –ë–î
            try:
                import requests
                headers = {
                    'apikey': SUPABASE_KEY,
                    'Authorization': f'Bearer {SUPABASE_KEY}',
                    'Content-Type': 'application/json'
                }
                url = f"{SUPABASE_URL}/rest/v1/modpack_builds?id=eq.{build_id}"
                requests.patch(url, headers=headers, json={'title': modpack_summary['title']}, timeout=10)
                print(f"‚úÖ [Build Updated] Title: {modpack_summary['title']}")
            except:
                pass  # –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–æ
        
        # ========================================================================
        # TIMING SUMMARY
        # ========================================================================
        total_time = time.time() - start_time
        
        print()
        print("=" * 80)
        print("‚è±Ô∏è  [TIMING SUMMARY]")
        print("=" * 80)
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º —ç—Ç–∞–ø—ã –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (–¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã)
        sorted_stages = sorted(stage_timings.items(), key=lambda x: x[1], reverse=True)
        
        for stage_name, duration in sorted_stages:
            percentage = (duration / total_time * 100) if total_time > 0 else 0
            print(f"   {stage_name:30s} {duration:6.2f}s ({percentage:5.1f}%)")
        
        print("-" * 80)
        print(f"   {'TOTAL':30s} {total_time:6.2f}s (100.0%)")
        print("=" * 80)
        print()
        
        # üéØ DASHBOARD: Emit pipeline completion
        if DASHBOARD_ENABLED:
            duration_ms = total_time * 1000
            total_tokens = result.get('_pipeline', {}).get('total_tokens', 0) if '_pipeline' in result else 0
            total_cost = result.get('_pipeline', {}).get('total_cost', 0.0) if '_pipeline' in result else 0.0
            emit_pipeline_completed(
                pipeline_id,
                duration_ms,
                total_tokens,
                total_cost,
                len(board_state['mods']),
                len(board_state['categories'])
            )
            emit_log(pipeline_id, "success", f"‚úÖ Pipeline completed! Generated {len(board_state['mods'])} mods in {len(board_state['categories'])} categories")
        
        return jsonify({
            'success': True,
            'board_state': board_state,  # –í–∫–ª—é—á–∞–µ—Ç _ai_build_id
            'build_id': build_id,  # ID —Å–±–æ—Ä–∫–∏ –¥–ª—è —Ñ–∏–¥–±–µ–∫–∞ (–æ—Ç–¥–µ–ª—å–Ω–æ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞)
            'explanation': result.get('explanation', ''),
            'summary': modpack_summary,  # –ù–æ–≤–∞—è —Å–≤–æ–¥–∫–∞ –¥–ª—è UI
            'stats': {
                'total_mods': len(board_state['mods']),
                'prompt': prompt,
                'mc_version': mc_version,
                'mod_loader': mod_loader
            }
        })
        
    except Exception as e:
        print(f"‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'error': 'Internal server error',
            'message': str(e)
        }), 500


@app.route('/api/ai/auto-sort', methods=['POST'])
def api_auto_sort():
    """
    AI Auto-Sort - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏—è –º–æ–¥–æ–≤ –Ω–∞ –¥–æ—Å–∫–µ
    """
    try:
        data = request.json
        
        # –í–∞–ª–∏–¥–∞—Ü–∏—è
        if not data or 'mods' not in data:
            return jsonify({
                'error': 'Invalid request',
                'message': 'mods array is required'
            }), 400
        
        board_mods = data['mods']
        max_categories = data.get('max_categories', 10)
        creativity = data.get('creativity', 5.0)  # 0-10
        user_prompt = data.get('prompt', '')
        
        # –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        if max_categories < 1 or max_categories > 50:
            return jsonify({
                'error': 'Invalid max_categories',
                'message': 'max_categories must be between 1 and 50'
            }), 400
        
        if creativity < 0 or creativity > 10:
            return jsonify({
                'error': 'Invalid creativity',
                'message': 'creativity must be between 0 and 10'
            }), 400
        
        print("=" * 80)
        print(f"üé® [Auto-Sort API] TWO-STAGE PIPELINE")
        print("=" * 80)
        print(f"   üì¶ Total mods: {len(board_mods)}")
        print(f"   üìä Max categories: {max_categories}")
        print(f"   üé® Creativity: {creativity}/10")
        if user_prompt:
            print(f"   üí¨ User prompt: {user_prompt}")
        print()
        
        # ========== STAGE 1: TAGGING ==========
        print("üìã STAGE 1: AI Tagging (analyzing each mod)")
        print("-" * 80)
        
        custom_tags_map, tagging_tokens = batch_get_mod_tags(
            mods=board_mods,
            deepseek_key=DEEPSEEK_API_KEY
        )
        
        # –ó–∞–º–µ–Ω—è–µ–º Modrinth —Ç–µ–≥–∏ –Ω–∞ –Ω–∞—à–∏ –∫–∞—Å—Ç–æ–º–Ω—ã–µ
        for mod in board_mods:
            mod_id = mod.get('source_id', mod.get('project_id', ''))
            if mod_id in custom_tags_map:
                mod['tags'] = custom_tags_map[mod_id]
                mod['categories'] = custom_tags_map[mod_id]  # –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        
        tagged_count = len([m for m in board_mods if m.get('tags')])
        print(f"‚úÖ STAGE 1 Complete: Tagged {tagged_count}/{len(board_mods)} mods")
        print()
        
        # ========== STAGE 2: CATEGORIZATION ==========
        print("üìÇ STAGE 2: AI Categorization (grouping mods by tags)")
        print("-" * 80)
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º tags_system.json
        import json
        tags_system_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'tags_system.json')
        
        try:
            with open(tags_system_path, 'r', encoding='utf-8') as f:
                tags_data = json.load(f)
                tags_system = []
                
                # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å–µ —Ç–µ–≥–∏ –∏–∑ –≤—Å–µ—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π
                if isinstance(tags_data, dict) and 'categories' in tags_data:
                    for category_name, category_data in tags_data['categories'].items():
                        if isinstance(category_data, dict) and 'tags' in category_data:
                            tags_system.extend(category_data['tags'])
                elif isinstance(tags_data, dict) and 'tags' in tags_data:
                    tags_system = list(tags_data['tags'].keys())
                elif isinstance(tags_data, list):
                    tags_system = tags_data
                
                print(f"   üè∑Ô∏è  Loaded {len(tags_system)} custom tags from tags_system.json")
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Could not load tags_system.json: {e}")
            import traceback
            traceback.print_exc()
            tags_system = []
        
        # –í—ã–∑—ã–≤–∞–µ–º AI Auto-Sort
        result = auto_sort_mods(
            board_mods=board_mods,
            tags_system=tags_system,
            max_categories=max_categories,
            creativity=creativity,
            user_prompt=user_prompt,
            deepseek_key=DEEPSEEK_API_KEY
        )
        
        if result.get('success'):
            print()
            print("=" * 80)
            print("‚úÖ TWO-STAGE PIPELINE COMPLETE")
            print("=" * 80)
            print(f"   üè∑Ô∏è  Tagged: {tagged_count}/{len(board_mods)} mods")
            print(f"   üìÇ Categorized: {result['stats']['categorized']}/{len(board_mods)} mods")
            print(f"   üìÅ Created: {result['stats']['categories_created']} categories")
            
            # –°—É–º–º–∞—Ä–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã –æ–±–æ–∏—Ö —ç—Ç–∞–ø–æ–≤
            total_tokens = tagging_tokens['total_tokens']
            total_cost = tagging_tokens['estimated_cost']
            
            if result.get('token_usage'):
                categorization_tokens = result['token_usage']
                total_tokens += categorization_tokens['total_tokens']
                total_cost += categorization_tokens['estimated_cost']
            
            print(f"\n   üí∞ TOTAL TOKEN USAGE:")
            print(f"      Stage 1 (Tagging): {tagging_tokens['total_tokens']:,} tokens (~${tagging_tokens['estimated_cost']:.6f})")
            if result.get('token_usage'):
                print(f"      Stage 2 (Categorization): {categorization_tokens['total_tokens']:,} tokens (~${categorization_tokens['estimated_cost']:.6f})")
            print(f"      TOTAL: {total_tokens:,} tokens (~${total_cost:.6f})")
            print("=" * 80)
            
            # ========== CACHE TO DATABASE ==========
            session_id = None
            try:
                import requests
                
                # –ü–æ–ª—É—á–∞–µ–º mc_version –∏ mod_loader –∏–∑ –∑–∞–ø—Ä–æ—Å–∞ (–µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω—ã) –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–µ—Ñ–æ–ª—Ç—ã
                mc_version = data.get('mc_version', 'unknown')
                mod_loader = data.get('mod_loader', 'fabric')
                
                # –§–æ—Ä–º–∏—Ä—É–µ–º input_mods (–º–∞—Å—Å–∏–≤ ID –º–æ–¥–æ–≤)
                input_mod_ids = [mod.get('source_id', mod.get('project_id', '')) for mod in board_mods]
                
                # –§–æ—Ä–º–∏—Ä—É–µ–º categories –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
                categories_to_save = result['categories']
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
                headers = {
                    'apikey': SUPABASE_KEY,
                    'Authorization': f'Bearer {SUPABASE_KEY}',
                    'Content-Type': 'application/json',
                    'Prefer': 'return=representation'
                }
                
                payload = {
                    'mc_version': mc_version,
                    'mod_loader': mod_loader,
                    'creativity': creativity,
                    'user_prompt': user_prompt if user_prompt else None,
                    'input_mods': input_mod_ids,
                    'categories': categories_to_save
                }
                
                response = requests.post(
                    f"{SUPABASE_URL}/rest/v1/ai_sort_sessions",
                    headers=headers,
                    json=payload,
                    timeout=10
                )
                
                if response.status_code in [200, 201]:
                    session_data = response.json()
                    if isinstance(session_data, list) and len(session_data) > 0:
                        session_id = session_data[0]['id']
                    elif isinstance(session_data, dict):
                        session_id = session_data.get('id')
                    print(f"\nüíæ [Cache] Saved AI sort session: {session_id}")
                else:
                    print(f"\n‚ö†Ô∏è  [Cache] Failed to save session: {response.status_code}")
            except Exception as e:
                print(f"\n‚ö†Ô∏è  [Cache] Error saving session: {e}")
            
            return jsonify({
                'success': True,
                'session_id': session_id,  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º session_id –¥–ª—è —Ñ–∏–¥–±–µ–∫–∞
                'categories': result['categories'],
                'mod_to_category': result['mod_to_category'],
                'stats': result['stats'],
                'fallback': result.get('fallback', False)
            })
        else:
            return jsonify({
                'success': False,
                'error': 'Categorization failed',
                'message': 'Could not categorize mods'
            }), 500
    
    except Exception as e:
        print(f"‚ùå [Auto-Sort API] Error: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'error': 'Internal server error',
            'message': str(e)
        }), 500


@app.route('/api/get-mod-tags', methods=['POST'])
def api_get_mod_tags():
    """
    –ü–æ–ª—É—á–∞–µ—Ç –∫–∞—Å—Ç–æ–º–Ω—ã–µ —Ç–µ–≥–∏ –¥–ª—è –º–æ–¥–æ–≤ –∏—Å–ø–æ–ª—å–∑—É—è AI
    """
    try:
        data = request.json
        
        if not data or 'mods' not in data:
            return jsonify({
                'error': 'Invalid request',
                'message': 'mods array is required'
            }), 400
        
        mods = data['mods']
        
        print(f"üè∑Ô∏è  [Get Mod Tags API] Processing {len(mods)} mods...")
        
        # –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Ç–µ–≥–∏ —á–µ—Ä–µ–∑ AI
        tags_map, token_usage = batch_get_mod_tags(
            mods=mods,
            deepseek_key=DEEPSEEK_API_KEY
        )
        
        print(f"‚úÖ [Get Mod Tags API] Tagged {len(tags_map)} mods")
        print(f"   üí∞ Tokens: {token_usage['total_tokens']:,} (~${token_usage['estimated_cost']:.6f})")
        
        return jsonify({
            'success': True,
            'tags': tags_map,
            'token_usage': token_usage
        })
        
    except Exception as e:
        print(f"‚ùå [Get Mod Tags API] Error: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'error': 'Internal server error',
            'message': str(e)
        }), 500


@app.route('/api/feedback/categorization', methods=['POST'])
def api_categorization_feedback():
    """
    –ü—Ä–∏–Ω–∏–º–∞–µ—Ç —Ñ–∏–¥–±–µ–∫ –æ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏–∏ –º–æ–¥–æ–≤
    –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤ modpack_builds –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
    """
    try:
        data = request.json
        
        # –í–∞–ª–∏–¥–∞—Ü–∏—è build_id
        build_id = data.get('build_id')
        if not build_id:
            return jsonify({
                'error': 'Invalid request',
                'message': 'build_id is required (should be from board_state._ai_build_id)'
            }), 400
        
        modpack_rating = data.get('modpack_rating')  # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: 1-5
        issues = data.get('issues', [])  # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –º–∞—Å—Å–∏–≤ –ø—Ä–æ–±–ª–µ–º
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞: —Ö–æ—Ç—è –±—ã rating –∏–ª–∏ issues –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å
        if modpack_rating is None and len(issues) == 0:
            return jsonify({
                'error': 'Invalid request',
                'message': 'Either modpack_rating or issues must be provided'
            }), 400
        
        # –í–∞–ª–∏–¥–∞—Ü–∏—è rating
        if modpack_rating is not None:
            if not isinstance(modpack_rating, (int, float)) or modpack_rating < 1 or modpack_rating > 5:
                return jsonify({
                    'error': 'Invalid request',
                    'message': 'modpack_rating must be between 1 and 5'
                }), 400
        
        # –í–∞–ª–∏–¥–∞—Ü–∏—è issues (–µ—Å–ª–∏ –µ—Å—Ç—å)
        if issues and not isinstance(issues, list):
            return jsonify({
                'error': 'Invalid request',
                'message': 'issues must be an array'
            }), 400
        
        # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
        if modpack_rating and len(issues) > 0:
            print(f"üì• [Categorization Feedback] Build {build_id}: ‚≠ê {modpack_rating}/5 + {len(issues)} issues")
        elif modpack_rating:
            print(f"üì• [Categorization Feedback] Build {build_id}: ‚≠ê {modpack_rating}/5 (rating only)")
        else:
            print(f"üì• [Categorization Feedback] Build {build_id}: {len(issues)} issues")
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∏–¥–±–µ–∫
        feedback_data = {
            'type': 'categorization_feedback',
            'submitted_at': datetime.now(UTC).isoformat()
        }
        
        if modpack_rating is not None:
            feedback_data['modpack_rating'] = modpack_rating
        
        if len(issues) > 0:
            feedback_data['issues'] = issues
        
        success = submit_feedback(
            build_id=build_id,
            feedback_data=feedback_data,
            supabase_url=SUPABASE_URL,
            supabase_key=SUPABASE_KEY
        )
        
        if success:
            print(f"‚úÖ [Categorization Feedback] Saved successfully")
            return jsonify({
                'success': True,
                'message': 'Thank you! Your feedback will help improve mod categorization.'
            })
        else:
            print(f"‚ö†Ô∏è  [Categorization Feedback] Failed to save")
            return jsonify({
                'success': False,
                'message': 'Failed to save feedback. Please try again.'
            }), 500
    
    except Exception as e:
        print(f"‚ùå [Categorization Feedback] Error: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'error': 'Internal server error',
            'message': str(e)
        }), 500


@app.route('/api/feedback/ai-sort', methods=['POST'])
def api_ai_sort_feedback():
    """
    –ü—Ä–∏–Ω–∏–º–∞–µ—Ç –æ—Ü–µ–Ω–∫—É (1-5 –∑–≤—ë–∑–¥) –¥–ª—è AI auto-sort —Å–µ—Å—Å–∏–∏
    """
    try:
        data = request.json
        
        # –í–∞–ª–∏–¥–∞—Ü–∏—è
        session_id = data.get('session_id')
        rating = data.get('rating')
        
        if not session_id:
            return jsonify({
                'error': 'Invalid request',
                'message': 'session_id is required'
            }), 400
        
        if not rating or not isinstance(rating, int) or rating < 1 or rating > 5:
            return jsonify({
                'error': 'Invalid request',
                'message': 'rating must be an integer between 1 and 5'
            }), 400
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∏–¥–±–µ–∫
        result = submit_sort_feedback(session_id, rating)
        
        if result.get('success'):
            return jsonify({
                'success': True,
                'message': 'Thank you for your feedback!'
            })
        else:
            return jsonify({
                'success': False,
                'message': 'Failed to save feedback',
                'error': result.get('error')
            }), 500
    
    except Exception as e:
        print(f"‚ùå [AI Sort Feedback API] Error: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'error': 'Internal server error',
            'message': str(e)
        }), 500


@app.route('/api/feedback', methods=['POST'])
def api_feedback():
    """
    –ü—Ä–∏–Ω–∏–º–∞–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π —Ñ–∏–¥–±–µ–∫ –æ –ø—Ä–æ–±–ª–µ–º–∞—Ö —Å –º–æ–¥–∞–º–∏ (–Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
    AI –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –ë–î
    """
    try:
        data = request.json
        
        if not data or 'feedback' not in data or 'board_state' not in data:
            return jsonify({
                'error': 'Invalid request',
                'message': 'feedback and board_state are required'
            }), 400
        
        feedback_text = data['feedback']
        board_state = data['board_state']
        
        print(f"üì¨ [Feedback API] Received feedback: {feedback_text[:100]}...")
        
        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ñ–∏–¥–±–µ–∫
        result = process_feedback(
            feedback_text=feedback_text,
            board_state=board_state,
            deepseek_key=DEEPSEEK_API_KEY,
            supabase_url=SUPABASE_URL,
            supabase_key=SUPABASE_KEY
        )
        
        if result.get('success'):
            print(f"‚úÖ [Feedback API] Processed successfully, {len(result.get('updates_made', []))} updates made")
            return jsonify({
                'success': True,
                'message': 'Thank you! Your feedback has been processed.',
                'updates': result.get('updates_made', [])
            })
        else:
            print(f"‚ö†Ô∏è  [Feedback API] Could not process: {result.get('reason', 'Unknown')}")
            return jsonify({
                'success': False,
                'message': 'Thank you for your feedback! We\'ll review it manually.',
                'reason': result.get('reason')
            })
    
    except Exception as e:
        print(f"‚ùå [Feedback API] Error: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'error': 'Internal server error',
            'message': str(e)
        }), 500


# –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º app –¥–ª—è Vercel
# Vercel –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–ø—É—Å—Ç–∏—Ç Flask app
if __name__ != '__main__':
    # Production mode (Vercel)
    pass
else:
    # Local development
    print("=" * 60)
    print("üöÄ ASTRAL AI API Server")
    print("=" * 60)
    print(f"Server running on: http://localhost:5000")
    print(f"Health check: http://localhost:5000/health")
    print(f"\nEndpoints:")
    print(f"  POST /api/ai/organize              - Organize mods into categories")
    print(f"  POST /api/ai/build                 - Build modpack from prompt")
    print(f"  POST /api/ai/build-board           - Build modpack as board_state.json")
    print(f"  POST /api/ai/auto-sort             - Auto-sort mods into categories")
    print(f"  POST /api/get-mod-tags             - Get custom tags for mods")
    print(f"  POST /api/feedback                 - Submit mod incompatibility feedback")
    print(f"  POST /api/feedback/categorization  - Submit categorization feedback")
    print("=" * 60)
    
    app.run(
        host='0.0.0.0',
        port=5000,
        debug=True
    )
